# Postgres Example

## Introduction
[PostgreSQL](https://www.postgresql.org/) is a widely used open-source database management system. Utilized either as a standalone database, or as a component of larger systems, Postgres can be used to manage anything from simple application logs to massive datasets.

In this example, we demonstrate how one can effectively and efficiently tune Postgres resources by utilizing [pgbench](https://www.postgresql.org/docs/10/pgbench.html), a customizable load tester for Postgres.

## Prerequisites

You must have a Kubernetes cluster. While this example will run on Minikube, we highly recommend using a cluster with 2 nodes, 4vCPUs (2 on each node) and 16GB of memory (8 on each node). Additionally, you will need a local configured copy of `kubectl`.

A local install of [Kustomize](https://github.com/kubernetes-sigs/kustomize/releases) (v3.1.0+) is required to manage the objects in you cluster.

Additionally, you will to initialize Red Sky Ops in your cluster. You can download a binary for your platform from the [releases page](https://github.com/redskyops/k8s-experiment/releases) and run `redskyctl init` (while connected to your cluster). For more details, see [the installation guide](install.md).

## Example Resources

The resources for this tutorial can be found in the [`/examples/postgres/`](https://github.com/redskyops/k8s-experiment/tree/master/examples/postgres) directory of the `k8s-experiment` source repository.

`kustomization.yaml`
: The input to Kustomize used to build the Kubernetes object manifests for this example.

* `experiment.yaml`
: The actual experiment object manifest; this includes the definition of the experiment itself (in terms of assignable parameters and observable metrics) as well as the instructions for carrying out the experiment (in terms of load generation and metric queries). Feel free to edit the parameter ranges and change the experiment name to avoid conflicting with other experiments in the cluster.

* `postgres.yaml`
: The manifest for the Postgres application.

* `secrets.yaml`
: Contains environment variables for the application.

In particular, the following parameters allow you to control the load to your database:
* `PGBENCH_SCALE`	Set this value to multiply the number of rows generated by the scale factor (for a scale of 1, pgbench will create 100,000 rows).
* `PGBENCH_CLIENTS`	Set this value to the number of clients to use for the benchmark.
* `PGBENCH_TRANSACTIONS` Set this value to configure the number of transactions each client runs.
* `PGBENCH_JOBS` Set this value to the number of worker threads to be used by pgbench.

More information can be found on the [pgbench](https://www.postgresql.org/docs/10/pgbench.html) and [crunchydata](https://access.crunchydata.com/documentation/crunchy-postgres-containers/2.4.1/container-specifications/crunchy-pgbench/) docs.

## Experiment Lifecycle

For every trial, two pods will come up:
1. A `postgres` pod that contains the database that trial will run against and get patched accordingly
2. An `<experiment-name>` pod which runs `pgbench` against the database - this is the actual trial pod

For more information on running, monitoring and maintaining experiments, please refer to our [quickstart](https://github.com/redskyops/k8s-experiment/blob/master/docs/quickstart.md) and [experiment lifecycle](https://github.com/gramLabs/k8s-experiment/blob/master/docs/lifecycle.md) documentation 
